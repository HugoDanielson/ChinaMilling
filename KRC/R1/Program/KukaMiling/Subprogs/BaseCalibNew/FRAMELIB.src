&ACCESS RV
&REL 2
DEF FRAMELIB( )

; An evolving collection of functions for frame manipulation

;

; Exported functions:

;   FRAME MAKEFRAME(ORIGIN,XPT,XYPT)

;   FRAME INTERPOLATE(STARTFRAME,ENDFRAME,FACTOR)

END



; Create a frame from an origin point, a point on the x-axis

; and a third point on the xy-plane

GLOBAL DEFFCT FRAME MAKEFRAME(ORIGIN :IN,XPT :IN,XYPT :IN)

  DECL E6POS ORIGIN,XPT,XYPT

  DECL VECTOR3DTYPE XDIR,YDIR,ZDIR

  DECL FRAME RESULT



  XDIR=VECFROM2PTS(ORIGIN,XPT)  

  NORMALISE(XDIR)

  YDIR=VECFROM2PTS(ORIGIN,XYPT)

  NORMALISE(ydir)

  ZDIR=CROSS(XDIR,YDIR)

  NORMALISE(ZDIR)

  YDIR=CROSS(ZDIR,XDIR)

  NORMALISE(YDIR)  



  RESULT=MAT2FRAMEABC(ORIGIN,XDIR,YDIR,ZDIR)



  RETURN(RESULT)

ENDFCT



; Create an interpolated frame from a start end end frame

; FACTOR is used to control how far between the 2 input frames the result is calcuated at

; eg. FACTOR=0 gives the start frame

;     FACTOR=1 gives the end frame

;     FACTOR=0.5 gives a frame half way between start and end frames

GLOBAL DEFFCT FRAME INTERPOLATE(STARTFRAME :IN,ENDFRAME :IN,FACTOR :IN)

  DECL FRAME STARTFRAME,ENDFRAME

  DECL FRAME DELTA,SUBDELTA

  DECL REAL FACTOR

  DECL FRAME RESULT

  DECL QUATERNIONTYPE Q1,Q2

  DECL AXISANGLETYPE AXISANGLE

  DECL VECTOR3DTYPE DELTAABC



  DELTA=INV_POS(STARTFRAME):ENDFRAME

  Q1=ABC2QUAT(DELTA)

  AXISANGLE=QUAT2AXISANGLE(Q1)

  AXISANGLE.THETA=AXISANGLE.THETA*FACTOR

  Q1=AXISANGLE2QUAT(AXISANGLE)

  DELTAABC=QUAT2ABC(Q1)



  SUBDELTA.X=DELTA.X*FACTOR

  SUBDELTA.Y=DELTA.Y*FACTOR

  SUBDELTA.Z=DELTA.Z*FACTOR

  SUBDELTA.A=DELTAABC.X

  SUBDELTA.B=DELTAABC.Y

  SUBDELTA.C=DELTAABC.Z



  RESULT=STARTFRAME:SUBDELTA



  RETURN(RESULT)

ENDFCT



; Convert ABC angles to a quaternion

DEFFCT QUATERNIONTYPE ABC2QUAT(ABC :IN)

  DECL FRAME ABC

  DECL REAL COSA,COSB,COSC,SINA,SINB,SINC

  DECL QUATERNIONTYPE Q



  COSA=COS(ABC.A/2)

  COSB=COS(ABC.B/2)

  COSC=COS(ABC.C/2)

  SINA=SIN(ABC.A/2)

  SINB=SIN(ABC.B/2)

  SINC=SIN(ABC.C/2)



  Q.Q1=SINC*COSB*COSA-COSC*SINB*SINA

  Q.Q2=COSC*SINB*COSA+SINC*COSB*SINA

  Q.Q3=COSC*COSB*SINA-SINC*SINB*COSA

  Q.Q4=COSC*COSB*COSA+SINC*SINB*SINA



  RETURN(Q)

ENDFCT



; Calculate the equivalent axis and angle of rotation from a quaternion

DEFFCT AXISANGLETYPE QUAT2AXISANGLE(Q :IN)

  DECL QUATERNIONTYPE Q

  DECL AXISANGLETYPE AXISANGLE

  REAL S



  S=SQRT(1-Q.Q4*Q.Q4)

  IF(ABS(S)<0.000001) THEN

    S=1

  ENDIF



  AXISANGLE.I=Q.Q1/S

  AXISANGLE.J=Q.Q2/S

  AXISANGLE.K=Q.Q3/S

  AXISANGLE.THETA=ACOS(Q.Q4)*2



  RETURN(AXISANGLE)

ENDFCT



; Calculate the quaternion from equivalent axis and angle of rotation

DEFFCT QUATERNIONTYPE AXISANGLE2QUAT(AXISANGLE :IN)

  DECL AXISANGLETYPE AXISANGLE

  DECL QUATERNIONTYPE Q

  REAL S,C

  

  S=SIN(AXISANGLE.THETA/2)

  C=COS(AXISANGLE.THETA/2)

  Q.Q1=AXISANGLE.I*S

  Q.Q2=AXISANGLE.J*s

  Q.Q3=AXISANGLE.K*S

  Q.Q4=C



  RETURN(Q)

ENDFCT



; Create ABC angles from a quaternion

DEFFCT VECTOR3DTYPE QUAT2ABC(Q :IN)

  DECL QUATERNIONTYPE Q

  DECL VECTOR3DTYPE ABC



  ABC.X=ATAN2(2*Q.Q4*Q.Q1+2*Q.Q2*Q.Q3,1-2*Q.Q1*Q.Q1-2*Q.Q2*Q.Q2)

  ABC.Y=ATAN2(2*Q.Q1*Q.Q2+2*Q.Q4*Q.Q3,1-2*Q.Q2*Q.Q2-2*Q.Q3*Q.Q3)

  ABC.Z=ATAN2(2*Q.Q4*Q.Q2-2*Q.Q1*Q.Q3,COS(ABC.X)*(1-2*Q.Q2*Q.Q2-2*Q.Q3*Q.Q3)+SIN(ABC.X)*(2*Q.Q1*Q.Q2+2*Q.Q4*Q.Q3))



  RETURN ABC

ENDFCT



; Create a frame from an origin point and 3 direction cosine vectors

DEFFCT FRAME MAT2FRAMEABC(ORIGIN :IN, XDIR :IN, YDIR :IN, ZDIR :IN)

  DECL E6POS ORIGIN

  DECL VECTOR3DTYPE XDIR, YDIR, ZDIR

  DECL FRAME RESULT



  RESULT.X=ORIGIN.X

  RESULT.Y=ORIGIN.Y

  RESULT.Z=ORIGIN.Z



  IF ABS(ABS(XDIR.Z) - 1) < 0.000001 THEN
halt
    RESULT.A=ATAN2(-YDIR.X,YDIR.Y)

    RESULT.B=ATAN2(-XDIR.Z,0)

    RESULT.C=0

  ELSE

    RESULT.A=ATAN2(XDIR.Y,XDIR.X)

    RESULT.B=ATAN2(-XDIR.Z,SQRT(YDIR.Z*YDIR.Z+ZDIR.Z*ZDIR.Z))

    RESULT.C=ATAN2(YDIR.Z,ZDIR.Z)

  ENDIF



  RETURN(RESULT)

ENDFCT



; Create a vector between 2 points

DEFFCT VECTOR3DTYPE VECFROM2PTS(STARTPT :IN,ENDPT :IN)

  DECL E6POS STARTPT,ENDPT

  DECL VECTOR3DTYPE RESULT



  RESULT.X=ENDPT.X-STARTPT.X

  RESULT.Y=ENDPT.Y-STARTPT.Y

  RESULT.Z=ENDPT.Z-STARTPT.Z



  RETURN(RESULT)

ENDFCT



; Return the cross product of 2 vectors

DEFFCT VECTOR3DTYPE CROSS(V1 :IN,V2 :IN)

  DECL VECTOR3DTYPE V1,V2,RESULT



  RESULT.X=V1.Y*V2.Z-V1.Z*V2.Y

  RESULT.Y=V1.Z*V2.X-V1.X*V2.Z

  RESULT.Z=V1.X*V2.Y-V1.Y*V2.X



  RETURN(RESULT)

ENDFCT



; Normalise a vector so that it's length is 1

DEF NORMALISE(VEC:OUT)

  DECL VECTOR3DTYPE VEC

  DECL REAL NORM

  

  NORM=VEC.X*VEC.X

  NORM=NORM+VEC.Y*VEC.Y

  NORM=NORM+VEC.Z*VEC.Z



  NORM=SQRT(NORM)



  VEC.X=VEC.X/NORM

  VEC.Y=VEC.Y/NORM

  VEC.Z=VEC.Z/NORM

END
